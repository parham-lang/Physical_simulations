<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² Ø­Ø±Ú©Øª Ù¾Ø±ØªØ§Ø¨ÛŒ - Ù…Ù‚ÛŒØ§Ø³ Ù‡Ù†Ø¯Ø³ÛŒ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100;400;700&display=swap');
        body {
            font-family: 'Vazirmatn', sans-serif;
            background-color: #0f172a; /* Ø¨Ø±Ú¯Ø±ÙØªÙ‡ Ø§Ø² Ú©Ø¯ Ø¯ÙˆÙ… */
            color: #f1f5f9; /* Ø¨Ø±Ú¯Ø±ÙØªÙ‡ Ø§Ø² Ú©Ø¯ Ø¯ÙˆÙ… */
            overflow: hidden;
        }
        canvas {
            background-color: #1e293b; /* Ø±Ù†Ú¯ Ø§Ø³Ù„ÛŒØª ØªÛŒØ±Ù‡ Ù…ØªÙ†Ø§Ø³Ø¨ Ø¨Ø§ ØªÙ… Ø¯ÙˆÙ… */
            border-bottom: 3px solid #334155;
            cursor: crosshair;
            touch-action: none;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }
        .control-panel {
            background: rgba(30, 41, 59, 0.8); /* Ø¨Ø±Ú¯Ø±ÙØªÙ‡ Ø§Ø² Ú©Ø¯ Ø¯ÙˆÙ… */
            backdrop-filter: blur(10px);
        }
        #tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(15, 23, 42, 0.95);
            color: #f1f5f9;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
            z-index: 100;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.3);
            line-height: 1.6;
        }
        .stat-highlight {
            transition: all 0.2s ease;
        }
        .stat-hovered {
            color: #60a5fa !important; /* Blue-400 Ù…Ø·Ø§Ø¨Ù‚ Ú©Ø¯ Ø¯ÙˆÙ… */
            transform: scale(1.05);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <div id="tooltip"></div>

    <header class="bg-slate-900 text-white p-4 shadow-lg border-b border-slate-800">
        <h1 class="text-2xl font-bold text-center text-blue-400">Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø­Ø±Ú©Øª Ù¾Ø±ØªØ§Ø¨ÛŒ</h1>
        <p class="text-sm text-center text-slate-400 mt-1">Ú©Ù†ØªØ±Ù„ Ù…Ù‚ÛŒØ§Ø³ Ø¨Ù‡ ØµÙˆØ±Øª Ù‡Ù†Ø¯Ø³ÛŒ Ø¨Ø±Ø§ÛŒ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ±</p>
    </header>

    <main class="flex-1 flex flex-col md:flex-row p-4 gap-4 overflow-hidden">
        
        <div class="flex-1 bg-slate-800 rounded-xl shadow-inner overflow-hidden flex flex-col relative" id="canvas-wrapper">
            <canvas id="simCanvas" class="w-full h-full"></canvas>
            
            <div id="statsBox" class="absolute top-4 left-4 bg-black/40 text-white p-3 rounded-lg text-sm border border-slate-700 backdrop-blur-sm space-y-1 transition-all">
                <div class="stat-highlight text-slate-300">Ø¨Ø±Ø¯ Ø§ÙÙ‚ÛŒ: <span id="statRange" class="font-mono text-green-400">0</span> Ù…ØªØ±</div>
                <div class="stat-highlight text-slate-300">Ø§ÙˆØ¬ Ø§Ø±ØªÙØ§Ø¹: <span id="statMaxHeight" class="font-mono text-yellow-400">0</span> Ù…ØªØ±</div>
                <div class="stat-highlight text-slate-300">Ø²Ù…Ø§Ù† Ù¾Ø±ÙˆØ§Ø²: <span id="statTime" class="font-mono text-blue-400">0</span> Ø«Ø§Ù†ÛŒÙ‡</div>
            </div>
        </div>

        <aside class="w-full md:w-80 space-y-4 overflow-y-auto pr-1">
            <div class="control-panel p-6 rounded-xl shadow-md border border-slate-700">
                <h2 class="text-lg font-bold mb-4 border-b border-slate-700 pb-2 text-blue-300">ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø±ØªØ§Ø¨</h2>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Ø²Ø§ÙˆÛŒÙ‡ Ù¾Ø±ØªØ§Ø¨ (Ø¯Ø±Ø¬Ù‡): <span id="valAngle" class="text-blue-400">45</span></label>
                    <input type="range" id="inputAngle" min="0" max="90" value="45" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Ø³Ø±Ø¹Øª Ø§ÙˆÙ„ÛŒÙ‡ (m/s): <span id="valVelocity" class="text-blue-400">50</span></label>
                    <input type="range" id="inputVelocity" min="10" max="150" value="50" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Ø´ØªØ§Ø¨ Ú¯Ø±Ø§Ù†Ø´ (m/sÂ²): <span id="valGravity" class="text-blue-400">9.8</span></label>
                    <input type="range" id="inputGravity" min="1" max="30" step="0.1" value="9.8" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <div class="mb-6 p-4 bg-slate-900/50 rounded-xl border border-slate-700">
                    <label class="block text-sm font-bold text-blue-300 mb-1 italic">ğŸ” Ù…Ù‚ÛŒØ§Ø³ Ù‡Ù†Ø¯Ø³ÛŒ (Zoom): <span id="valScale" class="text-blue-400 font-mono">5.00</span></label>
                    <input type="range" id="inputScale" min="-2" max="2" step="0.01" value="0.699" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                    <div class="flex justify-between text-[9px] text-slate-500 mt-1">
                        <span>Ø¯ÙˆØ± (x0.01)</span>
                        <span>Ù…Ø¹Ù…ÙˆÙ„ÛŒ (x1)</span>
                        <span>Ù†Ø²Ø¯ÛŒÚ© (x100)</span>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <button id="btnLaunch" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg transition-all shadow-md active:scale-95">Ø´Ù„ÛŒÚ© Ù¾Ø±ØªØ§Ø¨Ù‡</button>
                    <button id="btnClear" class="bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-lg transition-all">Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ</button>
                </div>
            </div>
            
            <div class="bg-slate-900/50 p-4 rounded-xl border border-slate-700 text-[11px] text-slate-400 leading-relaxed">
                <b class="text-blue-400">Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ ØªØ­Ù„ÛŒÙ„:</b> Ø¨Ø§ Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ù…ÙˆØ³ Ø±ÙˆÛŒ Ù‡Ø± Ù…Ø³ÛŒØ±ØŒ Ø¢Ù…Ø§Ø± Ø¯Ù‚ÛŒÙ‚ Ø¢Ù† (Ø¯Ø± Ú¯ÙˆØ´Ù‡ Ø¨Ø§Ù„Ø§ Ø³Ù…Øª Ú†Ù¾) Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ ØªØ§ Ø¨ØªÙˆØ§Ù†ÛŒØ¯ Ù¾Ø±ØªØ§Ø¨â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø§ Ù‡Ù… Ù…Ù‚Ø§ÛŒØ³Ù‡ Ú©Ù†ÛŒØ¯.
            </div>
        </aside>
    </main>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        const inputs = {
            angle: document.getElementById('inputAngle'),
            velocity: document.getElementById('inputVelocity'),
            gravity: document.getElementById('inputGravity'),
            scale: document.getElementById('inputScale')
        };
        const displays = {
            angle: document.getElementById('valAngle'),
            velocity: document.getElementById('valVelocity'),
            gravity: document.getElementById('valGravity'),
            scale: document.getElementById('valScale'),
            range: document.getElementById('statRange'),
            maxHeight: document.getElementById('statMaxHeight'),
            time: document.getElementById('statTime')
        };
        const btnLaunch = document.getElementById('btnLaunch');
        const btnClear = document.getElementById('btnClear');
        const statsBox = document.getElementById('statsBox');

        let projectiles = [];
        let currentScale = Math.pow(10, parseFloat(inputs.scale.value));
        const groundY = 50;
        let hoveredProjectile = null;

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function updateMainStatsUI(range, maxH, time, isHovered = false) {
            displays.range.innerText = range.toFixed(2);
            displays.maxHeight.innerText = maxH.toFixed(2);
            displays.time.innerText = time.toFixed(2);
            
            if (isHovered) {
                statsBox.classList.add('ring-2', 'ring-blue-500');
            } else {
                statsBox.classList.remove('ring-2', 'ring-blue-500');
            }
        }

        Object.keys(inputs).forEach(key => {
            inputs[key].addEventListener('input', () => {
                if (key === 'scale') {
                    currentScale = Math.pow(10, parseFloat(inputs.scale.value));
                    displays.scale.innerText = currentScale.toFixed(2);
                    projectiles.forEach(p => p.recalculatePoints());
                } else {
                    displays[key].innerText = inputs[key].value;
                }
            });
        });

        function distToSegment(p, v, w) {
            const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
            if (l2 === 0) return Math.sqrt(Math.pow(p.x - v.x, 2) + Math.pow(p.y - v.y, 2));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt(Math.pow(p.x - (v.x + t * (w.x - v.x)), 2) + Math.pow(p.y - (v.y + t * (w.y - v.y)), 2));
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let found = null;
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                for (let j = 0; j < p.points.length - 1; j++) {
                    const d = distToSegment({x: mouseX, y: mouseY}, p.points[j], p.points[j+1]);
                    if (d < 8) { 
                        found = p;
                        break;
                    }
                }
                if (found) break;
            }

            hoveredProjectile = found;

            if (hoveredProjectile) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.innerHTML = `
                    <div style="border-bottom: 1px solid rgba(59,130,246,0.3); margin-bottom: 6px; font-weight: bold; color: #60a5fa; font-size: 13px;">Ù…Ø´Ø®ØµØ§Øª Ø§ÛŒÙ† Ù…Ø³ÛŒØ±</div>
                    <div>ğŸš€ Ø³Ø±Ø¹Øª: ${hoveredProjectile.v0} m/s</div>
                    <div>ğŸ“ Ø²Ø§ÙˆÛŒÙ‡: ${hoveredProjectile.angleDeg}Â°</div>
                    <div>ğŸŒ Ú¯Ø±Ø§Ù†Ø´: ${hoveredProjectile.g} m/sÂ²</div>
                `;
                updateMainStatsUI(hoveredProjectile.theoRange, hoveredProjectile.theoMaxH, hoveredProjectile.theoTime, true);
            } else {
                tooltip.style.display = 'none';
                if (projectiles.length > 0) {
                    const last = projectiles[projectiles.length - 1];
                    updateMainStatsUI(
                        last.active ? last.lastX : last.theoRange,
                        last.theoMaxH,
                        last.active ? last.t_elapsed : last.theoTime,
                        false
                    );
                }
            }
        });

        class Projectile {
            constructor(v0, angleDeg, g) {
                this.v0 = v0;
                this.angleDeg = angleDeg;
                this.angle = (angleDeg * Math.PI) / 180;
                this.g = g;
                this.t_elapsed = 0;
                this.points = [];
                this.active = true;
                this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
                this.lastX = 0;
                
                this.theoRange = (Math.pow(v0, 2) * Math.sin(2 * this.angle)) / g;
                this.theoMaxH = (Math.pow(v0 * Math.sin(this.angle), 2)) / (2 * g);
                this.theoTime = (2 * v0 * Math.sin(this.angle)) / g;
            }

            recalculatePoints() {
                const step = 0.05;
                const newPoints = [];
                for (let time = 0; time <= this.t_elapsed; time += step) {
                    const x = this.v0 * Math.cos(this.angle) * time;
                    const y = (this.v0 * Math.sin(this.angle) * time) - (0.5 * this.g * Math.pow(time, 2));
                    newPoints.push({ x: x * currentScale, y: canvas.height - groundY - (y * currentScale) });
                }
                this.points = newPoints;
            }

            update(dt) {
                if (!this.active) return;

                this.t_elapsed += dt;
                const x = this.v0 * Math.cos(this.angle) * this.t_elapsed;
                const y = (this.v0 * Math.sin(this.angle) * this.t_elapsed) - (0.5 * this.g * Math.pow(this.t_elapsed, 2));

                if (y < 0 && this.t_elapsed > 0.05) {
                    this.active = false;
                    return;
                }

                this.lastX = x;
                this.points.push({ x: x * currentScale, y: canvas.height - groundY - (y * currentScale) });
                
                if (!hoveredProjectile) {
                    updateMainStatsUI(x, this.theoMaxH, this.t_elapsed, false);
                }
            }

            draw() {
                if (this.points.length < 2) return;

                const isHovered = (hoveredProjectile === this);
                ctx.beginPath();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = isHovered ? 6 : 3;
                
                if (isHovered) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                }

                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                const lastPoint = this.points[this.points.length - 1];
                ctx.beginPath();
                ctx.fillStyle = this.color;
                ctx.arc(lastPoint.x, lastPoint.y, isHovered ? 8 : 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function launch() {
            const p = new Projectile(
                parseFloat(inputs.velocity.value),
                parseFloat(inputs.angle.value),
                parseFloat(inputs.gravity.value)
            );
            projectiles.push(p);
        }

        btnLaunch.addEventListener('click', launch);
        btnClear.addEventListener('click', () => {
            projectiles = [];
            updateMainStatsUI(0, 0, 0, false);
            tooltip.style.display = 'none';
        });

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Ground Line - Adapted to Dark Theme
            ctx.beginPath();
            ctx.strokeStyle = "#475569";
            ctx.setLineDash([5, 5]);
            ctx.moveTo(0, canvas.height - groundY);
            ctx.lineTo(canvas.width, canvas.height - groundY);
            ctx.stroke();
            ctx.setLineDash([]);

            projectiles.forEach(p => {
                p.update(0.06);
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
